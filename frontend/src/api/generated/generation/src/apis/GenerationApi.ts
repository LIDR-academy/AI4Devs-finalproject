// @ts-nocheck
/* tslint:disable */
/* eslint-disable */
/**
 * Meditation Builder - Generation API
 * API for generating meditation content with professional narration and synchronized subtitles.  Bounded Context: **Generation** (separate from Composition/US2 and Playback/US4)  Core capability: - Generate meditation content: Transform composed text + music (+ optional image)
 * into narrated video or audio with synchronized subtitles  Architecture: Hexagonal (Ports & Adapters) BDD-First, API-First approach
 * MVP Infrastructure:
 * - TTS: Google Cloud Text-to-Speech (mocked with WireMock in tests)
 * - Rendering: FFmpeg (video/audio)
 * - Storage: S3 via LocalStack (tests) or AWS S3 (production)
 * - Persistence: PostgreSQL (schema: generation, table: meditation)
 * Authentication: JWT (blocked by US1 - bypass in tests via TestSecurityConfig)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import type {
  ErrorResponse,
  GenerateMeditationRequest,
  GenerationResponse,
} from '../models/index';
import {
  ErrorResponseFromJSON,
  ErrorResponseToJSON,
  GenerateMeditationRequestFromJSON,
  GenerateMeditationRequestToJSON,
  GenerationResponseFromJSON,
  GenerationResponseToJSON,
} from '../models/index';

export interface GenerateMeditationContentRequest {
  generateMeditationRequest: GenerateMeditationRequest;
}

export interface GetMeditationStatusRequest {
  meditationId: string;
}

/**
 *
 */
export class GenerationApi extends runtime.BaseAPI {
  /**
   * Asegura que this.basePath apunte SIEMPRE al backend configurado.
   * - Lee import.meta.env.VITE_API_BASE_URL (p.ej., "http://localhost:8080").
   * - Normaliza para que NO termine en "/".
   * - Evita tener que tocar Configuration({ basePath }).
   */
  private ensureBasePath = (): void => {
    const rawBase =
      (import.meta as any)?.env?.VITE_API_BASE_URL ?? 'http://localhost:8080';
    const base = String(rawBase).replace(/\/+$/, ''); // sin barra al final
    // BaseAPI expone basePath; lo reasignamos en caliente si cambia
    if ((this as any).basePath !== base) {
      (this as any).basePath = base;
    }
  };

  /**
   * Generate professional meditation content with:
   * - High-quality narration from text (Google Cloud TTS)
   * - Synchronized subtitles (SRT format)
   * - Video output (if image provided): narration + music + image + burned subtitles
   * - Audio output (if no image): narration + music, subtitles for future use
   *
   * Processing time validation:
   * - Estimates processing time before generation
   * - Rejects requests exceeding 187s timeout with 408 error
   *
   * Idempotency:
   * - Same (userId, text, musicRef, imageRef) → same meditationId
   * - Uses SHA-256 hash for deduplication
   *
   * Storage:
   * - S3 keys: `generation/{userId}/{meditationId}/(video.mp4|audio.mp3|subs.srt)`
   * - Response includes presigned URLs (TTL configurable)
   *
   * Maps to BDD scenarios:
   * - Scenario 1: "Generate narrated video with synchronized subtitles"
   * - Scenario 2: "Generate narrated podcast"
   * - Scenario 3: "Processing time exceeded"
   *
   * Generate meditation content with narration
   */
  async generateMeditationContentRaw(
    requestParameters: GenerateMeditationContentRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<GenerationResponse>> {
    if (requestParameters['generateMeditationRequest'] == null) {
      throw new runtime.RequiredError(
        'generateMeditationRequest',
        'Required parameter "generateMeditationRequest" was null or undefined when calling generateMeditationContent().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};
    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearerAuth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }

    // Asegura basePath en cada request (local, Vercel, etc.)
    this.ensureBasePath();

    // Path RELATIVO (nunca metas import.meta.env aquí)
    const path = `/api/v1/generation/meditations`;

    const response = await this.request(
      {
        path, // el runtime hará basePath + path
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: GenerateMeditationRequestToJSON(
          requestParameters['generateMeditationRequest']
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GenerationResponseFromJSON(jsonValue)
    );
  }

  /**
   * Generate meditation content with narration
   */
  async generateMeditationContent(
    requestParameters: GenerateMeditationContentRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<GenerationResponse> {
    const response = await this.generateMeditationContentRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Poll generation status and retrieve download URLs when complete. Used for async generation workflow.
   * Get meditation generation status
   */
  async getMeditationStatusRaw(
    requestParameters: GetMedititationStatusRequest, // nota: algunos generadores usan "GetMedititation..." con doble "ti"
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<GenerationResponse>> {
    if ((requestParameters as any)['meditationId'] == null) {
      throw new runtime.RequiredError(
        'meditationId',
        'Required parameter "meditationId" was null or undefined when calling getMeditationStatus().'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token('bearerAuth', []);

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`;
      }
    }

    // Asegura basePath
    this.ensureBasePath();

    // Path RELATIVO con sustitución del parámetro
    let path = `/api/v1/generation/meditations/{meditationId}`;
    path = path.replace(
      `{${'meditationId'}}`,
      encodeURIComponent(String((requestParameters as any)['meditationId']))
    );

    const response = await this.request(
      {
        path, // basePath + path
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GenerationResponseFromJSON(jsonValue)
    );
  }

  /**
   * Get meditation generation status
   */
  async getMedititationStatus( // nombre alternativo según el generador
    requestParameters: GetMeditationStatusRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<GenerationResponse> {
    const response = await this.getMeditationStatusRaw(
      requestParameters as any,
      initOverrides
    );
    return await response.value();
  }

  // Alias con el nombre "correcto" por si el template generó el método sin doble "ti"
  async getMeditationStatus(
    requestParameters: GetMeditationStatusRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<GenerationResponse> {
    return this.getMedititationStatus(requestParameters, initOverrides);
  }
}