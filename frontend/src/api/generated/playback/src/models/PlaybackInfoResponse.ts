/* tslint:disable */
/* eslint-disable */
/**
 * Meditation Builder - Playback API
 * API for listing and playing generated meditation content.  Bounded Context: **Playback** (separate from Composition/US2 and Generation/US3)  Core capabilities: - List User Meditations: Retrieve all meditations for the authenticated user with current processing states - Play Completed Meditation: Access multimedia content for playback (only COMPLETED meditations)  Architecture: Hexagonal (Ports & Adapters) BDD-First, API-First approach  MVP Infrastructure: - Persistence: PostgreSQL (schema: generation, table: meditations) - READ-ONLY from US3 - Storage: Media URLs point to S3 (managed by Generation BC/US3)  Business Rules: - Users can only see their own meditations (userId isolation enforced) - Only meditations with state COMPLETED can be played - State labels visible to users: \"En cola\", \"Generando\", \"Completada\", \"Fallida\"  Authentication: JWT (blocked by US1 - bypass in tests via TestSecurityConfig) 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { mapValues } from '../runtime';
import type { MediaUrls } from './MediaUrls';
import {
    MediaUrlsFromJSON,
    MediaUrlsFromJSONTyped,
    MediaUrlsToJSON,
    MediaUrlsToJSONTyped,
} from './MediaUrls';

/**
 * 
 * @export
 * @interface PlaybackInfoResponse
 */
export interface PlaybackInfoResponse {
    /**
     * Unique meditation identifier
     * @type {string}
     * @memberof PlaybackInfoResponse
     */
    id: string;
    /**
     * Meditation title
     * @type {string}
     * @memberof PlaybackInfoResponse
     */
    title: string;
    /**
     * Processing state (always COMPLETED for playback)
     * @type {string}
     * @memberof PlaybackInfoResponse
     */
    state: PlaybackInfoResponseStateEnum;
    /**
     * User-friendly state label
     * @type {string}
     * @memberof PlaybackInfoResponse
     */
    stateLabel: PlaybackInfoResponseStateLabelEnum;
    /**
     * Timestamp when meditation was created
     * @type {Date}
     * @memberof PlaybackInfoResponse
     */
    createdAt: Date;
    /**
     * 
     * @type {MediaUrls}
     * @memberof PlaybackInfoResponse
     */
    mediaUrls: MediaUrls;
}


/**
 * @export
 */
export const PlaybackInfoResponseStateEnum = {
    Completed: 'COMPLETED'
} as const;
export type PlaybackInfoResponseStateEnum = typeof PlaybackInfoResponseStateEnum[keyof typeof PlaybackInfoResponseStateEnum];

/**
 * @export
 */
export const PlaybackInfoResponseStateLabelEnum = {
    Completada: 'Completada'
} as const;
export type PlaybackInfoResponseStateLabelEnum = typeof PlaybackInfoResponseStateLabelEnum[keyof typeof PlaybackInfoResponseStateLabelEnum];


/**
 * Check if a given object implements the PlaybackInfoResponse interface.
 */
export function instanceOfPlaybackInfoResponse(value: object): value is PlaybackInfoResponse {
    if (!('id' in value) || value['id'] === undefined) return false;
    if (!('title' in value) || value['title'] === undefined) return false;
    if (!('state' in value) || value['state'] === undefined) return false;
    if (!('stateLabel' in value) || value['stateLabel'] === undefined) return false;
    if (!('createdAt' in value) || value['createdAt'] === undefined) return false;
    if (!('mediaUrls' in value) || value['mediaUrls'] === undefined) return false;
    return true;
}

export function PlaybackInfoResponseFromJSON(json: any): PlaybackInfoResponse {
    return PlaybackInfoResponseFromJSONTyped(json, false);
}

export function PlaybackInfoResponseFromJSONTyped(json: any, ignoreDiscriminator: boolean): PlaybackInfoResponse {
    if (json == null) {
        return json;
    }
    return {
        
        'id': json['id'],
        'title': json['title'],
        'state': json['state'],
        'stateLabel': json['stateLabel'],
        'createdAt': (new Date(json['createdAt'])),
        'mediaUrls': MediaUrlsFromJSON(json['mediaUrls']),
    };
}

export function PlaybackInfoResponseToJSON(json: any): PlaybackInfoResponse {
    return PlaybackInfoResponseToJSONTyped(json, false);
}

export function PlaybackInfoResponseToJSONTyped(value?: PlaybackInfoResponse | null, ignoreDiscriminator: boolean = false): any {
    if (value == null) {
        return value;
    }

    return {
        
        'id': value['id'],
        'title': value['title'],
        'state': value['state'],
        'stateLabel': value['stateLabel'],
        'createdAt': value['createdAt'].toISOString(),
        'mediaUrls': MediaUrlsToJSON(value['mediaUrls']),
    };
}

