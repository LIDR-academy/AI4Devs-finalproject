from typing import Optional, List, Dict, Any
from pydantic import BaseModel, Field, field_validator
from datetime import datetime
from enum import Enum
from uuid import UUID

class UploadRequest(BaseModel):
    """
    Schema for the upload request payload.

    Attributes:
        filename (str): The name of the file to upload. Must end with .3dm.
        size (int): The size of the file in bytes. Must be greater than 0.
        checksum (Optional[str]): optional checksum of the file for integrity verification.
    """
    filename: str = Field(..., description="Name of the file to upload (must be .3dm)")
    size: int = Field(..., gt=0, description="Size in bytes")
    checksum: Optional[str] = Field(None, description="Optional checksum for validation")

class UploadResponse(BaseModel):
    """
    Schema for the upload response payload.

    Attributes:
        upload_url (str): The presigned URL to upload the file to S3.
        file_id (str): The unique identifier assigned to the file.
        filename (str): The original filename.
    """
    upload_url: str = Field(..., description="Presigned URL for S3 upload")
    file_id: str = Field(..., description="Unique identifier for the file")
    filename: str = Field(..., description="Original filename")


# ===== T-004-BACK: Confirm Upload Schemas =====

class ConfirmUploadRequest(BaseModel):
    """
    Schema for confirming a completed file upload.

    This request is sent by the frontend after successfully uploading
    a file to the presigned URL, to trigger backend processing.

    Attributes:
        file_id (str): The unique identifier returned from the presigned URL request.
        file_key (str): The S3 object key where the file was uploaded.
    """
    file_id: str = Field(..., description="UUID of the uploaded file")
    file_key: str = Field(..., description="S3 object key (path in bucket)")


class ConfirmUploadResponse(BaseModel):
    """
    Schema for the confirm upload response.

    Attributes:
        success (bool): Whether the confirmation was successful.
        message (str): Human-readable status message.
        event_id (Optional[str]): ID of the created event record (if applicable).
        task_id (Optional[str]): ID of the launched Celery task (if applicable).
    """
    success: bool = Field(..., description="Confirmation status")
    message: str = Field(..., description="Status message")
    event_id: Optional[str] = Field(None, description="Created event record ID")
    task_id: Optional[str] = Field(None, description="Celery task ID for processing")


# ===== T-023-TEST: Validation Report Schemas =====

class ValidationErrorItem(BaseModel):
    """
    Schema for a single validation error.

    Attributes:
        category (str): Error category (e.g., "nomenclature", "geometry", "io").
        target (Optional[str]): Target element (layer name, object id, etc.).
        message (str): Human-readable error description.
    """
    category: str = Field(..., description="Error category")
    target: Optional[str] = Field(None, description="Target element identifier")
    message: str = Field(..., description="Error description")


class ValidationReport(BaseModel):
    """
    Schema for file validation report.

    This report is generated by the agent after processing a .3dm file
    and contains validation results, errors, and extracted metadata.

    Attributes:
        is_valid (bool): Whether the file passed all validation checks.
        errors (List[ValidationErrorItem]): List of validation errors found.
        metadata (Dict[str, Any]): Extracted metadata (user strings, layer info, etc.).
        validated_at (Optional[datetime]): Timestamp of validation.
        validated_by (Optional[str]): Worker or service that performed validation.
    """
    is_valid: bool = Field(..., description="Validation status")
    errors: List[ValidationErrorItem] = Field(default_factory=list, description="Validation errors")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Extracted metadata")
    validated_at: Optional[datetime] = Field(None, description="Validation timestamp")
    validated_by: Optional[str] = Field(None, description="Validator identifier")


# ===== T-030-BACK: Get Validation Status Endpoint Schemas =====

class BlockStatus(str, Enum):
    """
    Lifecycle states for blocks (parts).

    Synchronized with PostgreSQL ENUM block_status (T-021-DB).

    Valid transitions:
        uploaded -> processing -> validated | rejected | error_processing
        validated -> in_fabrication -> completed -> archived
        rejected -> uploaded (after fixes)
        error_processing -> uploaded (after manual review)
    """
    UPLOADED = "uploaded"
    PROCESSING = "processing"
    VALIDATED = "validated"
    REJECTED = "rejected"
    ERROR_PROCESSING = "error_processing"
    IN_FABRICATION = "in_fabrication"
    COMPLETED = "completed"
    ARCHIVED = "archived"


class ValidationStatusResponse(BaseModel):
    """
    Response schema for GET /api/parts/{id}/validation endpoint.

    Combines block metadata with validation report for frontend display.

    Attributes:
        block_id (UUID): Unique identifier of the block.
        iso_code (str): ISO code of the block (e.g., "PENDING-a1b2c3d4", "SAGR-Z1-001").
        status (BlockStatus): Current lifecycle state of the block.
        validation_report (Optional[ValidationReport]): Complete validation report (NULL if not validated yet).
        job_id (Optional[str]): Celery task ID if status=processing (for progress tracking).
    """
    block_id: UUID = Field(..., description="UUID of the block")
    iso_code: str = Field(..., description="ISO code identifier")
    status: BlockStatus = Field(..., description="Current block status")
    validation_report: Optional[ValidationReport] = Field(
        None,
        description="Validation report (NULL if not validated)"
    )
    job_id: Optional[str] = Field(
        None,
        description="Celery task ID for tracking (only if status=processing)"
    )

    class Config:
        json_schema_extra = {
            "example": {
                "block_id": "550e8400-e29b-41d4-a716-446655440000",
                "iso_code": "PENDING-a1b2c3d4",
                "status": "validated",
                "validation_report": {
                    "is_valid": True,
                    "errors": [],
                    "metadata": {
                        "total_objects": 42,
                        "valid_objects": 42,
                        "invalid_objects": 0,
                        "user_strings_extracted": 15
                    },
                    "validated_at": "2026-02-14T23:15:00Z",
                    "validated_by": "librarian-v1.0.0"
                },
                "job_id": None
            }
        }


# ===== T-0501-BACK: Parts Canvas API Schemas =====

class BoundingBox(BaseModel):
    """
    3D bounding box for spatial layout in canvas.

    Used by PartCanvasItem to represent geometry bounds extracted from Rhino models.
    Format matches THREE.js Box3 structure for frontend compatibility.

    Attributes:
        min: Array of [x, y, z] coordinates for minimum corner
        max: Array of [x, y, z] coordinates for maximum corner
    """
    min: List[float] = Field(..., min_length=3, max_length=3, description="Min corner [x, y, z]")
    max: List[float] = Field(..., min_length=3, max_length=3, description="Max corner [x, y, z]")

    @field_validator('min', 'max')
    @classmethod
    def validate_coordinates(cls, v):
        if len(v) != 3:
            raise ValueError('Must contain exactly 3 coordinates [x, y, z]')
        return v

    class Config:
        json_schema_extra = {
            "example": {
                "min": [-2.5, 0.0, -2.5],
                "max": [2.5, 5.0, 2.5]
            }
        }


class PartCanvasItem(BaseModel):
    """
    Minimal part info optimized for 3D canvas rendering.

    Contract: Must match TypeScript interface PartCanvasItem exactly.
    Used by GET /api/parts endpoint for Dashboard 3D (US-005).

    Attributes:
        id: Block UUID
        iso_code: Part identifier (ISO-19650 format, e.g., SF-C12-D-001)
        status: Lifecycle state (reuses existing BlockStatus enum)
        tipologia: Part typology (capitel, columna, dovela, clave, imposta, etc.)
        low_poly_url: Storage URL to simplified GLB file (~1000 triangles, ~300-400KB with Draco)
        bbox: 3D bounding box for camera centering and spatial queries
        workshop_id: Assigned workshop UUID (NULL if unassigned)
    """
    id: UUID = Field(..., description="Block UUID")
    iso_code: str = Field(..., description="Part identifier (e.g., SF-C12-D-001)")
    status: BlockStatus = Field(..., description="Lifecycle state")
    tipologia: str = Field(..., description="Part typology")
    low_poly_url: Optional[str] = Field(None, description="GLB file URL for 3D rendering")
    bbox: Optional[BoundingBox] = Field(None, description="3D bounding box")
    workshop_id: Optional[UUID] = Field(None, description="Assigned workshop UUID")

    class Config:
        json_schema_extra = {
            "example": {
                "id": "550e8400-e29b-41d4-a716-446655440000",
                "iso_code": "SF-C12-D-001",
                "status": "validated",
                "tipologia": "capitel",
                "low_poly_url": "https://xyz.supabase.co/storage/v1/object/public/processed-geometry/low-poly/550e8400.glb",
                "bbox": {"min": [-2.5, 0.0, -2.5], "max": [2.5, 5.0, 2.5]},
                "workshop_id": "123e4567-e89b-12d3-a456-426614174000"
            }
        }


class PartsListResponse(BaseModel):
    """
    Response for GET /api/parts endpoint.

    Attributes:
        parts: Array of all parts matching filters
        count: Total number of parts returned
        filters_applied: Echo of query parameters used for transparency
    """
    parts: List[PartCanvasItem] = Field(..., description="Array of canvas-ready parts")
    count: int = Field(..., description="Total count of parts returned")
    filters_applied: Dict[str, Any] = Field(default_factory=dict, description="Applied filters (for debugging)")

    class Config:
        json_schema_extra = {
            "example": {
                "parts": [
                    {
                        "id": "550e8400-e29b-41d4-a716-446655440000",
                        "iso_code": "SF-C12-D-001",
                        "status": "validated",
                        "tipologia": "capitel",
                        "low_poly_url": "https://xyz.supabase.co/storage/v1/object/public/processed-geometry/low-poly/550e8400.glb",
                        "bbox": {"min": [-2.5, 0, -2.5], "max": [2.5, 5, 2.5]},
                        "workshop_id": "123e4567-e89b-12d3-a456-426614174000"
                    }
                ],
                "count": 1,
                "filters_applied": {
                    "status": "validated",
                    "tipologia": "capitel",
                    "workshop_id": None
                }
            }
        }


# ===== T-1002-BACK: Get Part Detail API Schemas =====

class PartDetailResponse(BaseModel):
    """
    Detailed part info for 3D viewer modal (US-010).
    
    Contract: Must match TypeScript interface PartDetail exactly.
    Used by GET /api/parts/{id} endpoint.
    
    Attributes:
        id: Block UUID
        iso_code: Part identifier (ISO-19650 format)
        status: Lifecycle state
        tipologia: Part typology
        created_at: Row creation timestamp (ISO 8601 format)
        low_poly_url: Presigned CDN URL for GLB file (TTL 5min), None if not generated yet
        bbox: 3D bounding box for camera positioning
        workshop_id: Assigned workshop UUID (NULL if unassigned)
        workshop_name: Workshop human-readable name (NULL if unassigned)
        validation_report: Automatic validation results from The Librarian agent
        glb_size_bytes: File size of GLB in bytes (optional, from validation metadata)
        triangle_count: Number of triangles (optional, from validation metadata)
    """
    id: UUID = Field(..., description="Block UUID")
    iso_code: str = Field(..., description="Part identifier (e.g., SF-C12-D-001)")
    status: BlockStatus = Field(..., description="Lifecycle state")
    tipologia: str = Field(..., description="Part typology (capitel, columna, dovela, etc.)")
    created_at: str = Field(..., description="Creation timestamp (ISO 8601)")
    low_poly_url: Optional[str] = Field(None, description="Presigned CDN URL for GLB (TTL 5min)")
    bbox: Optional[BoundingBox] = Field(None, description="3D bounding box")
    workshop_id: Optional[UUID] = Field(None, description="Assigned workshop UUID")
    workshop_name: Optional[str] = Field(None, description="Workshop human-readable name")
    validation_report: Optional[ValidationReport] = Field(None, description="Validation results from agent")
    glb_size_bytes: Optional[int] = Field(None, description="GLB file size in bytes")
    triangle_count: Optional[int] = Field(None, description="Triangle count (for performance)")
    
    class Config:
        json_schema_extra = {
            "example": {
                "id": "550e8400-e29b-41d4-a716-446655440000",
                "iso_code": "SF-C12-D-001",
                "status": "validated",
                "tipologia": "capitel",
                "created_at": "2026-02-15T10:30:00Z",
                "low_poly_url": "https://d1234abcd.cloudfront.net/low-poly/550e8400.glb?X-Amz-Expires=300&...",
                "bbox": {"min": [-2.5, 0.0, -2.5], "max": [2.5, 5.0, 2.5]},
                "workshop_id": "123e4567-e89b-12d3-a456-426614174000",
                "workshop_name": "Taller Granollers",
                "validation_report": {
                    "is_valid": True,
                    "errors": [],
                    "metadata": {"layer_count": 5, "object_count": 12}
                },
                "glb_size_bytes": 425984,
                "triangle_count": 1024
            }
        }


# ===== T-1003-BACK: Part Navigation API Schemas =====

class PartNavigationResponse(BaseModel):
    """
    Response for GET /api/parts/{id}/adjacent endpoint.
    
    Provides prev/next IDs for sequential navigation between parts in the 3D viewer modal.
    Order is determined by created_at ASC (oldest first), with filters applied.
    
    Contract: Must match TypeScript interface PartNavigationResponse exactly.
    Used by US-010 for Prev/Next buttons in modal footer.
    
    Attributes:
        prev_id: UUID of previous part in sequence (None if current is first)
        next_id: UUID of next part in sequence (None if current is last)
        current_index: 1-based position of current part in filtered set (e.g., 42 of 150)
        total_count: Total number of parts in filtered set
    """
    prev_id: Optional[UUID] = Field(None, description="Previous part UUID (None if first)")
    next_id: Optional[UUID] = Field(None, description="Next part UUID (None if last)")
    current_index: int = Field(..., ge=1, description="1-based index of current part")
    total_count: int = Field(..., ge=0, description="Total parts in filtered set")
    
    class Config:
        json_schema_extra = {
            "example": {
                "prev_id": "123e4567-e89b-12d3-a456-426614174000",
                "next_id": "987fcdeb-51a2-43e7-9876-543210fedcba",
                "current_index": 42,
                "total_count": 150
            }
        }
