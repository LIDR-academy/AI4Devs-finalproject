# T-0501-BACK: List Parts with Geometry Metadata

**Ticket ID:** T-0501-BACK  
**Story:** US-005 - Dashboard 3D Interactivo  
**Sprint:** 1 (Semana 1-2)  
**Estimaci√≥n:** 3 Story Points (~6 horas)  
**Responsable:** Backend Lead  
**Prioridad:** P0 (Blocking T-0505)

---

## üìã CONTEXT

### Problem Statement
El Dashboard 3D necesita cargar 150+ piezas con geometr√≠a low-poly (~778 KB cada una seg√∫n POC). Endpoint actual `GET /api/parts` no incluye:
- URL del archivo .glb simplificado
- Bounding box para posicionamiento espacial
- Metadata optimizado para rendering (sin payloads pesados innecesarios)

### Current State
```python
# Endpoint actual (src/backend/api/parts.py)
@router.get("/")
async def list_parts(
    limit: int = 50,  # Paginaci√≥n actual
    offset: int = 0,
    db: Session = Depends(get_db)
):
    # Retorna solo metadata b√°sico, sin low_poly_url
    pass
```

### Target State
```python
@router.get("/")
async def list_parts_canvas(
    # Sin paginaci√≥n para canvas (ALL parts needed for 3D scene)
    status: Optional[BlockStatus] = None,
    tipologia: Optional[Tipologia] = None,
    workshop_id: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Endpoint optimizado para Dashboard 3D.
    Retorna ALL parts con low_poly_url + bbox.
    RLS: Usuarios workshop solo ven sus piezas.
    """
    pass
```

---

## üéØ REQUIREMENTS

### FR-1: Remove Pagination (Canvas needs ALL parts)
```python
# CHANGE FROM:
limit: int = 50, offset: int = 0

# CHANGE TO:
# No limit/offset params
# Return all parts matching filters (max ~500 in production)
```

**Justification:** Canvas 3D renderiza todas las piezas simult√°neamente en scene. Paginaci√≥n no tiene sentido en contexto 3D espacial.

**Performance Mitigation:**
- Response size <200 KB even with 500 items (schema optimizado)
- Frontend caching con React Query (stale-while-revalidate)
- Database index on filter columns (`idx_blocks_canvas_query`)

### FR-2: Add low_poly_url Field
```python
# Schema Response
class PartCanvasItem(BaseModel):
    id: str
    iso_code: str
    status: BlockStatus
    tipologia: Tipologia
    low_poly_url: Optional[HttpUrl] = None  # NEW: URL S3 del GLB simplificado
    bbox: Optional[BoundingBox] = None      # NEW: Para posicionamiento
    workshop_id: Optional[str] = None
    workshop_name: Optional[str] = None
```

**`low_poly_url` Source:**
- Column `blocks.low_poly_url` (a√±adido en T-0503-DB)
- Generated by `T-0502-AGENT` tras validaci√≥n
- Format: `https://supabase.co/storage/v1/object/public/processed-geometry/low-poly/{block_id}.glb`
- NULL if processing pending or failed

### FR-3: Add Bounding Box Calculation
```python
class BoundingBox(BaseModel):
    min: List[float]  # [x, y, z]
    max: List[float]  # [x, y, z]
```

**Calculation Strategy:**
- Option A (Preferred): Extract from Rhino metadata (`blocks.rhino_metadata->'bounding_box'`)
- Option B (Fallback): Parse GLB file and calculate (expensive, avoid)
- Option C (MVP): Return NULL, frontend uses default grid positioning

**Recommendation:** Start with Option C (NULL), implement Option A in Sprint 2 cuando metadata est√© completo.

### FR-4: Filter Parameters
```python
status: Optional[BlockStatus] = None
    # Values: uploaded, validated, in_fabrication, completed, archived
    # Example: ?status=validated

tipologia: Optional[Tipologia] = None
    # Values: capitel, columna, dovela, clave, imposta
    # Example: ?tipologia=capitel

workshop_id: Optional[str] = None
    # UUID del taller asignado
    # Example: ?workshop_id=123e4567-e89b-12d3-a456-426614174000
```

**SQL WHERE Clause:**
```sql
WHERE 
    is_archived = false
    AND (COALESCE(:status, status) = status)
    AND (COALESCE(:tipologia, tipologia) = tipologia)
    AND (:workshop_id IS NULL OR workshop_id = :workshop_id)
```

### FR-5: Row Level Security (RLS)
```python
# Apply RLS BEFORE query execution
def apply_rls_filter(query: Query, user: User) -> Query:
    """
    Role logic:
    - admin/bim_manager: See ALL parts
    - workshop: See only assigned parts (workshop_id = user.workshop_id)
    - viewer: See all (read-only)
    """
    if user.role == 'workshop':
        query = query.filter(
            or_(
                Block.workshop_id == user.workshop_id,
                Block.workshop_id.is_(None)  # Unassigned parts
            )
        )
    return query
```

### FR-6: Response Size Optimization
**Target:** <200 KB for 500 parts

**Optimizations:**
1. **Denormalize workshop_name** (avoid JOIN in every request)
   ```sql
   SELECT 
       b.id,
       b.iso_code,
       b.status,
       b.tipologia,
       b.low_poly_url,
       b.bbox,
       b.workshop_id,
       w.name as workshop_name  -- Pre-join once
   ```

2. **Remove unnecessary fields:**
   - ‚ùå `original_file_url` (not needed for canvas)
   - ‚ùå `rhino_metadata` (too heavy, ~50 KB per part)
   - ‚ùå `created_at`, `updated_at` (not displayed)

3. **Use database indexes:**
   ```sql
   CREATE INDEX idx_blocks_canvas_query 
   ON blocks(status, tipologia, workshop_id) 
   WHERE is_archived = false;
   ```

---

## üî® IMPLEMENTATION

### Step 1: Update Pydantic Schemas (10 min)
**File:** `src/backend/schemas.py`

```python
from pydantic import BaseModel, HttpUrl
from typing import List, Optional, Literal

# Enums
BlockStatus = Literal["uploaded", "validated", "in_fabrication", "completed", "archived"]
Tipologia = Literal["capitel", "columna", "dovela", "clave", "imposta"]

# Bounding Box
class BoundingBox(BaseModel):
    """3D bounding box for spatial positioning"""
    min: List[float]  # [x, y, z]
    max: List[float]  # [x, y, z]
    
    class Config:
        schema_extra = {
            "example": {
                "min": [-2.5, 0.0, -2.5],
                "max": [2.5, 5.0, 2.5]
            }
        }

# Canvas Item (optimized schema)
class PartCanvasItem(BaseModel):
    """Lightweight schema for 3D rendering (100 bytes per item)"""
    id: str
    iso_code: str
    status: BlockStatus
    tipologia: Tipologia
    low_poly_url: Optional[HttpUrl] = None
    bbox: Optional[BoundingBox] = None
    workshop_id: Optional[str] = None
    workshop_name: Optional[str] = None
    
    class Config:
        orm_mode = True
        schema_extra = {
            "example": {
                "id": "123e4567-e89b-12d3-a456-426614174000",
                "iso_code": "SF-C12-D-001",
                "status": "validated",
                "tipologia": "capitel",
                "low_poly_url": "https://xyz.supabase.co/storage/v1/object/public/processed-geometry/low-poly/123e4567.glb",
                "bbox": {"min": [-2.5, 0, -2.5], "max": [2.5, 5, 2.5]},
                "workshop_id": "ws-001",
                "workshop_name": "Taller Granollers"
            }
        }

# Response Wrapper
class PartCanvasResponse(BaseModel):
    """Response with metadata"""
    data:List[PartCanvasItem]
    meta: dict  # { total: int, filtered: int, has_pending_processing: bool }
    
    class Config:
        schema_extra = {
            "example": {
                "data": [],  # List of PartCanvasItem
                "meta": {
                    "total": 150,
                    "filtered": 23,
                    "has_pending_processing": 5
                }
            }
        }
```

### Step 2: Create RLS Helper (15 min)
**File:** `src/backend/services/rls.py`

```python
from sqlalchemy.orm import Query
from src.backend.models import Block, User
from sqlalchemy import or_

def apply_rls_blocks(query: Query, user: User) -> Query:
    """
    Apply Row Level Security to blocks query.
    
    Rules:
    - admin/bim_manager: See ALL
    - workshop: See only assigned + unassigned
    - viewer: See ALL (read-only enforced in endpoints)
    """
    if user.role == 'workshop':
        query = query.filter(
            or_(
                Block.workshop_id == user.workshop_id,
                Block.workshop_id.is_(None)
            )
        )
    return query
```

### Step 3: Update Endpoint (30 min)
**File:** `src/backend/api/parts.py`

```python
from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session, joinedload
from src.backend.database import get_db
from src.backend.dependencies import get_current_user
from src.backend.schemas import (
    PartCanvasResponse, 
    PartCanvasItem, 
    BlockStatus, 
    Tipologia
)
from src.backend.models import Block, Workshop, User
from src.backend.services.rls import apply_rls_blocks
from typing import Optional

router = APIRouter(prefix="/parts", tags=["parts"])

@router.get("/", response_model=PartCanvasResponse)
async def list_parts_canvas(
    status: Optional[BlockStatus] = None,
    tipologia: Optional[Tipologia] = None,
    workshop_id: Optional[str] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    List all parts optimized for 3D Dashboard canvas.
    
    **NO PAGINATION** - Returns ALL parts matching filters.
    
    **Filters:**
    - `status`: uploaded | validated | in_fabrication | completed
    - `tipologia`: capitel | columna | dovela | clave | imposta
    - `workshop_id`: UUID del taller
    
    **RLS Applied:**
    - Workshops only see assigned + unassigned parts
    - Admins see all
    
    **Performance:**
    - Uses index `idx_blocks_canvas_query`
    - Response size <200 KB for 500 parts
    - Denormalized workshop_name (no N+1)
    """
    # Base query with workshop JOIN
    query = db.query(
        Block,
        Workshop.name.label('workshop_name')
    ).outerjoin(
        Workshop, Block.workshop_id == Workshop.id
    )
    
    # Apply RLS
    query = apply_rls_blocks(query, current_user)
    
    # Base filters
    query = query.filter(Block.is_archived == False)
    
    # Optional filters
    if status:
        query = query.filter(Block.status == status)
    if tipologia:
        query = query.filter(Block.tipologia == tipologia)
    if workshop_id:
        query = query.filter(Block.workshop_id == workshop_id)
    
    # Execute query
    results = query.all()
    
    # Transform to response schema
    data = []
    pending_processing = 0
    
    for block, workshop_name in results:
        # Count parts without low_poly_url
        if not block.low_poly_url:
            pending_processing += 1
        
        data.append(PartCanvasItem(
            id=str(block.id),
            iso_code=block.iso_code,
            status=block.status,
            tipologia=block.tipologia,
            low_poly_url=block.low_poly_url,
            bbox=block.bbox,  # May be None in MVP
            workshop_id=str(block.workshop_id) if block.workshop_id else None,
            workshop_name=workshop_name
        ))
    
    # Metadata
    meta = {
        "total": len(data),
        "filtered": len(data),  # After filters
        "has_pending_processing": pending_processing
    }
    
    return PartCanvasResponse(data=data, meta=meta)
```

### Step 4: Add Route to Main App (5 min)
**File:** `src/backend/main.py`

```python
from src.backend.api import parts

app.include_router(parts.router, prefix="/api")
```

---

## ‚úÖ DEFINITION OF DONE

### Acceptance Criteria
- [ ] **AC-1:** `GET /api/parts` returns ALL parts (no pagination)
- [ ] **AC-2:** Response includes `low_poly_url` field (nullable)
- [ ] **AC-3:** Filter `?status=validated` only returns validated parts
- [ ] **AC-4:** Filter `?tipologia=capitel` only returns capiteles
- [ ] **AC-5:** Workshop user only sees assigned + unassigned parts
- [ ] **AC-6:** Admin user sees all parts regardless of assignment
- [ ] **AC-7:** Response size <200 KB for 150 parts
- [ ] **AC-8:** Query uses index `idx_blocks_canvas_query` (verify with `EXPLAIN ANALYZE`)
- [ ] **AC-9:** Response time <500 ms for 150 parts
- [ ] **AC-10:** OpenAPI docs show correct schema with examples

### Quality Gates
```bash
# Query performance
psql -c "EXPLAIN ANALYZE SELECT ...;"
# Should use idx_blocks_canvas_query

# Response size
curl -s http://localhost:8000/api/parts | wc -c
# Should be <200000 bytes

# Response time
curl -w "@curl-format.txt" http://localhost:8000/api/parts
# Should be <500 ms
```

---

## üß™ TESTING

### Unit Tests
**File:** `src/backend/tests/unit/test_rls.py`

```python
from src.backend.services.rls import apply_rls_blocks
from src.backend.tests.fixtures import create_user, create_block

def test_rls_admin_sees_all(db_session):
    admin = create_user(role='admin')
    block1 = create_block(workshop_id='ws-1')
    block2 = create_block(workshop_id='ws-2')
    
    query = db_session.query(Block)
    query = apply_rls_blocks(query, admin)
    
    assert query.count() == 2  # Sees both

def test_rls_workshop_sees_only_assigned(db_session):
    workshop_user = create_user(role='workshop', workshop_id='ws-1')
    block1 = create_block(workshop_id='ws-1')
    block2 = create_block(workshop_id='ws-2')
    block3 = create_block(workshop_id=None)
    
    query = db_session.query(Block)
    query = apply_rls_blocks(query, workshop_user)
    
    results = query.all()
    assert len(results) == 2  # ws-1 + unassigned
    assert block2 not in results  # ws-2 hidden
```

### Integration Tests
**File:** `src/backend/tests/integration/test_parts_canvas.py`

```python
from fastapi.testclient import TestClient

def test_list_parts_returns_all_no_pagination(client: TestClient, seed_data):
    """Should return ALL 150 parts without pagination"""
    response = client.get("/api/parts")
    
    assert response.status_code == 200
    data = response.json()
    
    assert len(data["data"]) == 150
    assert data["meta"]["total"] == 150

def test_list_parts_includes_low_poly_url(client: TestClient, seed_data):
    """Response should include low_poly_url field"""
    response = client.get("/api/parts")
    
    part = response.json()["data"][0]
    assert "low_poly_url" in part
    # May be None if not processed yet

def test_filter_by_status(client: TestClient, seed_data):
    """Filter ?status=validated should only return validated"""
    response = client.get("/api/parts?status=validated")
    
    data = response.json()["data"]
    assert all(p["status"] == "validated" for p in data)

def test_rls_workshop_user(client: TestClient, workshop_user_token, seed_data):
    """Workshop user should only see assigned parts"""
    headers = {"Authorization": f"Bearer {workshop_user_token}"}
    response = client.get("/api/parts", headers=headers)
    
    data = response.json()["data"]
    # Should not include other workshops
    assert all(
        p["workshop_id"] in [None, workshop_user.workshop_id] 
        for p in data
    )

def test_response_size_limit(client: TestClient, seed_500_parts):
    """Response should be <200 KB even with 500 parts"""
    response = client.get("/api/parts")
    
    size_kb = len(response.content) / 1024
    assert size_kb < 200, f"Response too large: {size_kb} KB"

def test_query_uses_index(db_session):
    """Query should use idx_blocks_canvas_query"""
    from sqlalchemy import text
    
    explain = db_session.execute(text(
        "EXPLAIN ANALYZE SELECT * FROM blocks WHERE status='validated'"
    ))
    
    plan = explain.fetchall()
    assert any("idx_blocks_canvas_query" in str(row) for row in plan)
```

### Performance Test
```python
import time

def test_response_time_under_500ms(client: TestClient, seed_150_parts):
    """Endpoint should respond <500ms"""
    start = time.time()
    response = client.get("/api/parts")
    elapsed = (time.time() - start) * 1000
    
    assert response.status_code == 200
    assert elapsed < 500, f"Too slow: {elapsed}ms"
```

---

## üì¶ DELIVERABLES

1. ‚úÖ Pydantic schemas: `PartCanvasItem`, `BoundingBox`, `PartCanvasResponse`
2. ‚úÖ RLS service: `services/rls.py` with `apply_rls_blocks()`
3. ‚úÖ Updated endpoint: `GET /api/parts` (no pagination, all filters)
4. ‚úÖ Unit tests: `test_rls.py` (5+ tests)
5. ‚úÖ Integration tests: `test_parts_canvas.py` (8+ tests)
6. ‚úÖ OpenAPI docs updated with examples
7. ‚úÖ Performance benchmark: Response time <500ms, size <200KB

---

## üîó DEPENDENCIES

### Upstream (Must Complete First)
- `T-0503-DB`: Column `low_poly_url` must exist
- `T-0503-DB`: Index `idx_blocks_canvas_query` created

### Downstream (Blocked by This)
- `T-0505-FRONT`: Parts rendering needs this endpoint

### External
- Database RLS policies configured in Supabase
- Workshop table populated with test data

---

## ‚ö†Ô∏è RISKS & MITIGATION

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| **Response >200 KB** | High | Medium | Monitor with test, optimize schema, add compression |
| **Query >500ms** | Medium | Low | Use index, add query caching, denormalize workshop |
| **N+1 query problem** | High | Low | Use `joinedload` for workshops, verify with SQL logging |
| **RLS bypass** | Critical | Low | Comprehensive unit + integration tests, code review |

---

**Status:** ‚úÖ Ready for Implementation  
**Last Updated:** 2026-02-18  
**Dependencies:** T-0503-DB (low_poly_url column + index)
